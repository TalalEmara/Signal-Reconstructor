Index: Core/Data_load.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\n\r\nclass DataLoader:\r\n    \"\"\"Class to load data from a CSV file.\"\"\"\r\n\r\n    def __init__(self, file_path):\r\n        \"\"\"Initialize with the path to the CSV file.\"\"\"\r\n        self.file_path = file_path\r\n        self.data = None\r\n        self.load_data()\r\n\r\n    def load_data(self):\r\n        \"\"\"Load data from the CSV file into a DataFrame.\"\"\"\r\n        try:\r\n            # Load the CSV file, assuming headers\r\n            self.data = pd.read_csv(self.file_path)\r\n\r\n            # Drop rows where all columns are NaN (if any)\r\n            self.data.dropna(how='all', inplace=True)\r\n\r\n            # Convert data to numeric, coercing errors to NaN\r\n            self.data = self.data.apply(pd.to_numeric, errors='coerce')\r\n\r\n            print(\"Data loaded successfully.\")\r\n            # print(self.data.head())  # Print first few rows of the loaded data for verification\r\n        except FileNotFoundError:\r\n            print(f\"Error: The file {self.file_path} was not found.\")\r\n        except Exception as e:\r\n            print(f\"An error occurred: {e}\")\r\n\r\n    def get_data(self):\r\n        \"\"\"Return the loaded data.\"\"\"\r\n        return self.data.to_numpy()\r\n\r\n\r\n\r\nclass DataPlotter:\r\n    \"\"\"Class to plot data using Matplotlib.\"\"\"\r\n\r\n    def __init__(self, data):\r\n        \"\"\"Initialize with the data to be plotted.\"\"\"\r\n        self.data = data\r\n\r\n    def plot(self, x_index, y_index, title='Signal Plot', x_label='Time', y_label='Amplitude'):\r\n        \"\"\"Plot the signal using specified column indices.\"\"\"\r\n        if self.data is not None:\r\n            plt.figure(figsize=(12, 6))  # Wider figure\r\n\r\n            # Create time axis (x_index can be either time or sample index)\r\n            x_data = self.data.iloc[:, x_index]\r\n            y_data = self.data.iloc[:, y_index]\r\n\r\n            # Plot the data as a signal\r\n            plt.plot(x_data, y_data, color='blue', linewidth=1)\r\n\r\n            # Set the title and labels\r\n            plt.title(title)\r\n            plt.xlabel(x_label)\r\n            plt.ylabel(y_label)\r\n\r\n            # Set x and y limits to accommodate the signal range\r\n            plt.xlim(x_data.min(), x_data.max())  # X-axis based on time or samples\r\n            plt.ylim(y_data.min() - 1, y_data.max() + 1)  # Adjust y-limits as needed\r\n\r\n            plt.grid(True)\r\n            plt.show()\r\n        else:\r\n            print(\"Error: No data to plot.\")\r\n\r\n\r\n\r\ndef main():\r\n    \"\"\"Main function to run the data loading and plotting.\"\"\"\r\n    # Replace 'your_file.csv' with the path to your CSV file\r\n    csv_file_path = \"signals_data/ECG_Normal.csv\"\r\n\r\n    # Create a DataLoader instance and load data\r\n    data_loader = DataLoader(csv_file_path)\r\n    data_loader.load_data()\r\n\r\n    # Get the loaded data\r\n    data = data_loader.get_data()\r\n\r\n    # Create a DataPlotter instance and plot the data\r\n    if data is not None:\r\n        data_plotter = DataPlotter(data)\r\n\r\n        # Assuming the first column is Time and the second column is Value\r\n        num_columns = data.shape[1]\r\n\r\n        if num_columns >= 2:\r\n            data_plotter.plot(x_index=0, y_index=1, title='Signal Plot', x_label='Time (s)', y_label='Amplitude')\r\n        else:\r\n            print(\"Error: The data does not have enough columns for plotting.\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Core/Data_load.py b/Core/Data_load.py
--- a/Core/Data_load.py	(revision 31031d20a9f15037c813b1a7e605c11f854f9f7a)
+++ b/Core/Data_load.py	(date 1730150519905)
@@ -32,7 +32,7 @@
 
     def get_data(self):
         """Return the loaded data."""
-        return self.data.to_numpy()
+        return self.data.to_numpy()[:1000]
 
 
 
Index: GUI/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom PyQt5.QtCore import Qt\r\nfrom PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QAction, QVBoxLayout, QWidget, QHBoxLayout, QSplitter\r\nfrom pyqtgraph import PlotWidget, mkPen\r\nimport sys\r\nimport os\r\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\r\nfrom toolbar import ToolBar\r\nfrom Composer import Composer\r\nfrom Core.Data_load import DataLoader\r\nfrom Core.mixer import mixer, remove_elements\r\nfrom Core.noise import add_noise\r\nfrom Core.mainCore import sample_and_reconstruct, sinc_interp,linear_interp, calculate_max_frequency,zoh_reconstruction,cubic_spline_interp\r\n\r\nclass MainApp(QMainWindow):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        self.old_amplitude = None\r\n        self.old_frequency = None\r\n        self.old_type = None\r\n\r\n\r\n        self.interp_methods = {\r\n            \"Whittaker-Shannon (sinc)\": sinc_interp,\r\n            \"Linear\": linear_interp,\r\n            \"Zero-Order Hold\": zoh_reconstruction,\r\n            \"Cubic-Spline\":cubic_spline_interp\r\n        }\r\n        self.interp_method = self.interp_methods[\"Whittaker-Shannon (sinc)\"]\r\n\r\n        self.signalData = self.generate_default_data()\r\n        self.signalfMax = calculate_max_frequency(self.signalData[:, 1],self.signalData[:, 0])\r\n        print(self.signalfMax)\r\n\r\n\r\n        self.sampling_rate = 900\r\n\r\n        # self.reconstructedSignalData = self.generate_default_data()\r\n\r\n\r\n        # self.data_loader = DataLoader(file_path)\r\n        # self.signalData = self.data_loader.get_data()\r\n        self.mixedSignalData = None  \r\n        self.reconstructedSignalData = self.signalData\r\n\r\n        \r\n\r\n        self.setWindowTitle(\"Signal\")\r\n        self.resize(1080, 720)\r\n        self.setWindowState(Qt.WindowMaximized)\r\n        self.setStyleSheet(\"background-color: #f0f1f5;\")\r\n\r\n\r\n        self.controlBar = ToolBar()\r\n        self.controlBar.signalfMax = self.signalfMax\r\n\r\n\r\n\r\n        self.snr_enabled = False\r\n        # self.controlBar.setStyleSheet(\"background:red;\")\r\n        self.controlBar.dataLoaded.connect(self.updateSignalData)\r\n        self.controlBar.dataLoaded.connect(lambda data: self.updateSignalData(data.to_numpy()))\r\n        self.controlBar.snrEnabledChanged.connect(self.set_snr_enabled)\r\n        self.controlBar.snrChanged.connect(self.updateNoise)\r\n        self.controlBar.samplingRateChanged.connect(self.updateSamplingRate)\r\n        self.controlBar.methodChanged.connect(self.updateSamplingMethod)\r\n\r\n\r\n        self.current_signal_index = None  \r\n      \r\n\r\n        self.composer = Composer()\r\n        self.composer.valueAdded.connect(self.add_mixed_signal)\r\n        self.composer.valueUpdated.connect(self.update_table_mixed_signal)\r\n        self.composer.valueRemoved.connect(self.remove_element)\r\n        # self.composer.setStyleSheet(\"background:blue;\")\r\n\r\n        self.originalSignal = PlotWidget()\r\n        self.originalSignal.setLabel('left', 'Amplitude')\r\n        self.originalSignal.setLabel('bottom', 'Time', units='s')\r\n        self.originalSignal.addLegend()\r\n\r\n        self.noisySignal = PlotWidget()\r\n\r\n        self.reconstructedSignal = PlotWidget()\r\n        # self.reconstructedSignal.setStyleSheet(\"background:purple;\")\r\n\r\n        self.diffrenceGraph = PlotWidget()\r\n        # self.diffrenceGraph.setStyleSheet(\"background:light blue;\")\r\n\r\n        self.frequencyDomain = PlotWidget()\r\n        # self.frequencyDomain.setStyleSheet(\"background:dark grey;\")\r\n\r\n        self.mainLayout = QHBoxLayout()\r\n        self.controlBarLayout = QHBoxLayout()\r\n        self.workspace = QHBoxLayout()\r\n        self.graphsLayout = QVBoxLayout()\r\n        self.workspace = QVBoxLayout()\r\n        self.composerLayout = QVBoxLayout()\r\n        self.graphsLayout = QVBoxLayout()\r\n        self.originalSignalLayout = QHBoxLayout()\r\n        self.reconstructedSignalLayout = QHBoxLayout()\r\n        self.comparisonLayout = QHBoxLayout()\r\n        self.diffrenceGraphLayout = QVBoxLayout()\r\n        self.frequencyDomainLayout = QVBoxLayout()\r\n\r\n        # self.comparisonLayout.addLayout(self.diffrenceGraphLayout)\r\n        # self.comparisonLayout.addLayout(self.frequencyDomainLayout)\r\n\r\n        self.graphsLayout.addLayout(self.originalSignalLayout,35)\r\n        self.graphsLayout.addLayout(self.reconstructedSignalLayout,35)\r\n        self.graphsLayout.addLayout(self.comparisonLayout,30)\r\n\r\n        self.workspace.addLayout(self.controlBarLayout,5)\r\n        self.workspace.addLayout(self.graphsLayout,95)\r\n\r\n        self.mainLayout.addLayout(self.workspace,80)\r\n        self.mainLayout.addLayout(self.composerLayout,20)\r\n\r\n        self.controlBarLayout.addWidget(self.controlBar)\r\n        self.composerLayout.addWidget(self.composer)\r\n        self.originalSignalLayout.addWidget(self.originalSignal)\r\n        self.reconstructedSignalLayout.addWidget(self.reconstructedSignal)\r\n        self.diffrenceGraphLayout.addWidget(self.diffrenceGraph)\r\n        self.frequencyDomainLayout.addWidget(self.frequencyDomain)\r\n\r\n        self.splitter = QSplitter(Qt.Horizontal)\r\n        self.splitter.addWidget(self.diffrenceGraph)\r\n        self.splitter.addWidget(self.frequencyDomain)\r\n        self.comparisonLayout.addWidget(self.splitter)\r\n\r\n        mainWidget = QWidget()\r\n        mainWidget.setLayout(self.mainLayout)\r\n        self.setCentralWidget(mainWidget)\r\n\r\n        self.updateSignalData(self.signalData) \r\n\r\n        #limit x \r\n        self.originalSignal.sigXRangeChanged.connect(lambda: self.limit_x_axis(self.originalSignal))\r\n        self.reconstructedSignal.sigXRangeChanged.connect(lambda: self.limit_x_axis(self.reconstructedSignal))\r\n        self.diffrenceGraph.sigXRangeChanged.connect(lambda: self.limit_x_axis(self.diffrenceGraph))\r\n        self.frequencyDomain.sigXRangeChanged.connect(lambda: self.limit_x_axis(self.frequencyDomain))\r\n\r\n    def limit_x_axis(self, plot_widget):\r\n        x_min, x_max = plot_widget.viewRange()[0]\r\n        if x_min < 0:\r\n            plot_widget.setXRange(0, x_max, padding=0)\r\n    \r\n    def set_snr_enabled(self, enabled):\r\n        self.snr_enabled = enabled\r\n        self.updateSignalData(self.signalData)\r\n    \r\n    def updateNoise(self, snr_value):\r\n        if not self.snr_enabled: \r\n            return\r\n      \r\n        if self.mixedSignalData is not None:\r\n            x = self.mixedSignalData[:, 0]\r\n            y = self.mixedSignalData[:, 1]\r\n        else:\r\n            x = self.signalData[:, 0]\r\n            y = self.signalData[:, 1]\r\n\r\n        noisy_signal = add_noise(y, snr_value)\r\n        \r\n        self.originalSignal.clear()\r\n        self.originalSignal.plot(x, y, pen=mkPen(color=\"b\", width=2), name=\"Original or Mixed Signal\")\r\n        self.originalSignal.plot(x, noisy_signal, pen=mkPen(color=\"r\", width=1, style=Qt.DashLine), name=\"Noisy Signal\")\r\n\r\n        self.plot_frequency_domain(y, noisy_signal, x[1] - x[0])\r\n\r\n    def generate_default_data(self): #testing\r\n        time = np.linspace(0, 1, 1000)\r\n        amplitude = np.sin(2 * np.pi * 122 * time)\r\n        return np.column_stack((time, amplitude))\r\n\r\n    def updateSamplingRate(self, samplingRate):\r\n        self.sampling_rate = int(samplingRate)\r\n        print(samplingRate)\r\n        print(self.sampling_rate)\r\n        try:\r\n            self.updateSignalData(self.signalData)\r\n        except Exception as e:\r\n            # Handle the exception (e.g., log it or show a message)\r\n            print(f\"An error occurred while updating signal data: {e}\")\r\n\r\n    def updateSamplingMethod(self, method):\r\n        print(method)\r\n        self.interp_method = self.interp_methods[method]\r\n        print(self.interp_method)\r\n        self.updateSignalData(self.signalData)\r\n    def updateSignalData(self, data):\r\n        self.signalData = np.array(data)\r\n        snr_value = self.controlBar.snrSlider.value()\r\n        \r\n        print(\"data\")\r\n        if self.signalData.shape[1] >= 2:\r\n            x = self.signalData[:, 0]\r\n            y = self.signalData[:, 1]\r\n\r\n            self.originalSignal.clear()\r\n            self.originalSignal.plot(x, y, pen=mkPen(color=\"b\", width=2), name=\"Original Signal\")\r\n                \r\n            if self.snr_enabled:\r\n                noisy_signal = add_noise(y, snr_value)\r\n                self.originalSignal.plot(x, noisy_signal, pen=mkPen(color=\"r\", width=1, style=Qt.DashLine), name=\"Noisy Signal\")\r\n\r\n            else:\r\n                noisy_signal = y\r\n\r\n        self.sampledTime,self.sampledSignal,self.reconstructedSignalData = sample_and_reconstruct(self.signalData[:, 0], self.signalData[:, 1], self.sampling_rate, self.interp_method)\r\n        x = self.signalData[:, 0]\r\n        y = self.reconstructedSignalData\r\n        # print(np.dim(y))\r\n\r\n        self.originalSignal.plot(self.sampledTime, self.sampledSignal,symbol='o', symbolSize=8, symbolBrush='b')\r\n\r\n        self.reconstructedSignal.clear()\r\n        self.reconstructedSignal.plot(x, y, pen=mkPen(color=\"b\", width=2), name=\"Original Signal\")\r\n\r\n        print(\"Signal Data Updated:\")\r\n        print(self.signalData)\r\n\r\n        self.diffrenceGraph.clear()\r\n        if self.signalData.shape[1] >= 2 and self.reconstructedSignalData.ndim == 1:\r\n            difference = self.calculate_difference(self.signalData[:, 1], self.reconstructedSignalData)\r\n            self.diffrenceGraph.plot(self.signalData[:, 0], difference, pen=mkPen(color=\"r\", width=2),\r\n                                     name=\"Difference\")\r\n\r\n        self.plot_frequency_domain(self.signalData[:, 1], noisy_signal, self.signalData[1, 0] - self.signalData[0, 0])\r\n\r\n        self.add_frequency_domain(self.reconstructedSignalData , self.signalData[1, 0] - self.signalData[0, 0])\r\n\r\n    def calculate_difference(self, signal1, signal2):\r\n\r\n        length = max(len(signal1), len(signal2))\r\n        padded_signal1 = np.pad(signal1, (0, length - len(signal1)), 'constant')\r\n        padded_signal2 = np.pad(signal2, (0, length - len(signal2)), 'constant')\r\n        return padded_signal1 - padded_signal2\r\n\r\n    import numpy as np\r\n\r\n    def add_frequency_domain(self, reconstructedSignalData, time_difference):\r\n        reconstructedSignalData = np.array(reconstructedSignalData)\r\n\r\n        # Perform FFT\r\n        fft_result = np.fft.fft(reconstructedSignalData)\r\n\r\n        N = len(reconstructedSignalData)\r\n        frequencies = np.fft.fftfreq(N, d=time_difference)\r\n\r\n        # Calculate the magnitude of the FFT\r\n        magnitude = np.abs(fft_result)\r\n\r\n        # Check if frequency and magnitude arrays are correctly formed\r\n        if len(frequencies) != len(magnitude):\r\n            print(\"Length mismatch between frequencies and magnitudes!\")\r\n            return\r\n\r\n        # Plot the positive frequencies and their corresponding magnitudes\r\n        self.frequencyDomain.plot(frequencies[:N // 2], magnitude[:N // 2], pen=(255, 0, 0), width=2)\r\n\r\n        # Optionally, set the axis limits for better visibility\r\n        self.frequencyDomain.setXRange(0, np.max(frequencies[:N // 2]), padding=0)\r\n        self.frequencyDomain.setYRange(0, np.max(magnitude[:N // 2]), padding=0)\r\n    def plot_frequency_domain(self, original_amplitude, noisy_amplitude,time_step):\r\n        N = len(original_amplitude)\r\n\r\n        original_fft_values = np.fft.fft(original_amplitude)\r\n        original_fft_frequencies = np.fft.fftfreq(N, d=time_step)\r\n        original_positive_frequencies = original_fft_frequencies[:N // 2]\r\n        original_magnitudes = np.abs(original_fft_values[:N // 2])\r\n\r\n        noisy_fft_values = np.fft.fft(noisy_amplitude)\r\n        noisy_magnitudes = np.abs(noisy_fft_values[:N // 2])\r\n\r\n\r\n        self.frequencyDomain.clear()\r\n        self.frequencyDomain.plot(original_positive_frequencies, original_magnitudes, pen=mkPen(color=\"b\", width=2), name=\"Original Signal Frequency Domain\")\r\n        \r\n        if self.snr_enabled:\r\n            self.frequencyDomain.plot(original_positive_frequencies, noisy_magnitudes, pen=mkPen(color=\"r\", width=1, style=Qt.DashLine), name=\"Noisy Signal Frequency Domain\")\r\n    \r\n    def add_mixed_signal(self, amplitude, frequency, signal_type):\r\n        self.old_amplitude = amplitude\r\n        self.old_frequency = frequency\r\n        self.old_type = signal_type\r\n\r\n        mixed_signal = mixer(self.signalData, amplitude, frequency,signal_type)\r\n        # print(self.signalData[:, 1])\r\n        self.signalData = np.column_stack((self.signalData[:, 0], mixed_signal)) \r\n        # print(self.signalData[:, 1])\r\n\r\n\r\n        # self.originalSignal.clear()\r\n        # self.originalSignal.plot(self.signalData[:, 0], mixed_signal, pen=mkPen(color=\"b\", width=2), name=\"Mixed Signal\")\r\n        combined_signal = np.column_stack((self.signalData[:, 0], mixed_signal))\r\n\r\n        self.updateSignalData(combined_signal)\r\n\r\n        snr_value = self.controlBar.snrSlider.value()\r\n        noisy_signal = add_noise(mixed_signal, snr_value) if self.snr_enabled else mixed_signal\r\n\r\n        self.originalSignal.plot(self.signalData[:, 0], noisy_signal, pen=mkPen(color=\"r\", width=1, style=Qt.DashLine), name=\"Noisy Mixed Signal\")\r\n        time_step = self.signalData[1, 0] - self.signalData[0, 0]\r\n        self.plot_frequency_domain(mixed_signal, noisy_signal, time_step)\r\n\r\n    def update_table_mixed_signal(self, row, amplitude, frequency,signal_type):\r\n        old_signal = remove_elements(self.signalData, self.old_amplitude, self.old_frequency, self.old_type)\r\n        updated_signal = mixer(np.column_stack((self.signalData[:, 0], old_signal)), amplitude, frequency, signal_type)\r\n        \r\n        self.old_amplitude = amplitude\r\n        self.old_frequency = frequency\r\n        self.old_type = signal_type\r\n\r\n        self.signalData = np.column_stack((self.signalData[:, 0], updated_signal))\r\n\r\n        self.originalSignal.clear()\r\n        self.originalSignal.plot(self.signalData[:, 0], updated_signal, pen=mkPen(color=\"b\", width=2), name=f\"Updated Signal Row {row}\")\r\n\r\n        combined_signal = np.column_stack((self.signalData[:, 0], updated_signal))\r\n\r\n        self.updateSignalData(combined_signal)\r\n\r\n\r\n        snr_value = self.controlBar.snrSlider.value()\r\n        noisy_signal = add_noise(updated_signal, snr_value) if self.snr_enabled else updated_signal\r\n        self.originalSignal.plot(self.signalData[:, 0], noisy_signal, pen=mkPen(color=\"r\", width=1, style=Qt.DashLine), name=\"Noisy Updated Signal\")\r\n\r\n    def remove_element(self, amplitude, frequency, signal_type):\r\n        # Remove the specified elements from the signal data\r\n        old_signal = remove_elements(self.signalData, amplitude, frequency, signal_type)\r\n        \r\n        # Update the signalData with the modified signal\r\n        self.signalData = np.column_stack((self.signalData[:, 0], old_signal))\r\n\r\n        # Clear the previous plot\r\n        self.originalSignal.clear()\r\n        \r\n        # Plot the updated mixed signal\r\n        self.originalSignal.plot(self.signalData[:, 0], old_signal, pen=mkPen(color=\"b\", width=2), name=\"Updated Mixed Signal After Removal\")\r\n        \r\n        combined_signal = np.column_stack((self.signalData[:, 0], old_signal))\r\n\r\n        self.updateSignalData(combined_signal)\r\n\r\n\r\n        # Get the current SNR value and add noise if enabled\r\n        snr_value = self.controlBar.snrSlider.value()\r\n        noisy_signal = add_noise(old_signal, snr_value) if self.snr_enabled else old_signal\r\n        \r\n        # Plot the noisy version of the updated signal\r\n        self.originalSignal.plot(self.signalData[:, 0], noisy_signal, pen=mkPen(color=\"r\", width=1, style=Qt.DashLine), name=\"Noisy Updated Signal After Removal\")\r\n        \r\n        # Update frequency domain plot\r\n        time_step = self.signalData[1, 0] - self.signalData[0, 0]\r\n        self.plot_frequency_domain(old_signal, noisy_signal, time_step)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    csv_file_path = 'signals_data/ECG_Normal.csv'\r\n    app = QApplication(sys.argv)\r\n    main_app = MainApp()\r\n    main_app.show()\r\n    sys.exit(app.exec_())\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/GUI/main.py b/GUI/main.py
--- a/GUI/main.py	(revision 31031d20a9f15037c813b1a7e605c11f854f9f7a)
+++ b/GUI/main.py	(date 1730150456942)
@@ -13,7 +13,7 @@
 from Core.mainCore import sample_and_reconstruct, sinc_interp,linear_interp, calculate_max_frequency,zoh_reconstruction,cubic_spline_interp
 
 class MainApp(QMainWindow):
-    def __init__(self):
+    def __init__(self,csv_file_path):
         super().__init__()
 
         self.old_amplitude = None
@@ -29,7 +29,10 @@
         }
         self.interp_method = self.interp_methods["Whittaker-Shannon (sinc)"]
 
-        self.signalData = self.generate_default_data()
+        # self.signalData = self.generate_default_data()
+        self.data_loader = DataLoader(csv_file_path)  # Load data from CSV
+        self.signalData = self.data_loader.get_data()  # Get the loaded data as a NumPy array
+
         self.signalfMax = calculate_max_frequency(self.signalData[:, 1],self.signalData[:, 0])
         print(self.signalfMax)
 
@@ -359,9 +362,9 @@
 
 
 if __name__ == "__main__":
-    csv_file_path = 'signals_data/ECG_Normal.csv'
+    csv_file_path = '../signals_data/ECG_Abnormal.csv'
     app = QApplication(sys.argv)
-    main_app = MainApp()
+    main_app = MainApp(csv_file_path)
     main_app.show()
     sys.exit(app.exec_())
 
Index: Core/mainCore.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\r\nimport numpy as np\r\nimport pandas as pd\r\nfrom PyQt5 import QtCore, QtWidgets\r\nimport pyqtgraph as pg\r\nfrom scipy.fft import fft, fftfreq\r\nfrom scipy.interpolate import CubicSpline\r\n\r\nclass DataLoader:\r\n    \"\"\"Class to load data from a CSV file.\"\"\"\r\n\r\n    def __init__(self, file_path):\r\n        \"\"\"Initialize with the path to the CSV file.\"\"\"\r\n        self.file_path = file_path\r\n        self.data = None\r\n        self.load_data()\r\n\r\n    def load_data(self):\r\n        \"\"\"Load data from the CSV file into a DataFrame.\"\"\"\r\n        try:\r\n            # Load the CSV file, assuming headers\r\n            self.data = pd.read_csv(self.file_path)\r\n\r\n            # Drop rows where all columns are NaN (if any)\r\n            self.data.dropna(how='all', inplace=True)\r\n\r\n            # Convert data to numeric, coercing errors to NaN\r\n            self.data = self.data.apply(pd.to_numeric, errors='coerce')\r\n\r\n            print(\"Data loaded successfully.\")\r\n        except FileNotFoundError:\r\n            print(f\"Error: The file {self.file_path} was not found.\")\r\n        except Exception as e:\r\n            print(f\"An error occurred: {e}\")\r\n\r\n    def get_data(self):\r\n        \"\"\"Return the first 1000 points of the loaded data as a NumPy array.\"\"\"\r\n        return self.data.to_numpy()[:1000]\r\n\r\n\r\ndef sinc_interp(sample_points, sample_values, interpolated_points):\r\n    T = sample_points[1] - sample_points[0]\r\n    return np.array([np.sum(sample_values * np.sinc((t_i - sample_points) / T)) for t_i in interpolated_points])\r\n\r\ndef linear_interp(sample_points, sample_values, interpolated_points):\r\n    return np.interp(interpolated_points, sample_points, sample_values)\r\n\r\ndef zoh_reconstruction(sample_points, sample_values, interpolated_points):\r\n\r\n    reconstructed_signal = np.zeros_like(interpolated_points)\r\n    \r\n    # Loop through each interval and hold the last sample value constant until the next sampled point\r\n    for i in range(len(sample_points) - 1):\r\n        \r\n        mask = (interpolated_points >= sample_points[i]) & (interpolated_points < sample_points[i + 1])\r\n        reconstructed_signal[mask] = sample_values[i]\r\n\r\n    reconstructed_signal[interpolated_points >= sample_points[-1]] = sample_values[-1]\r\n    \r\n    return reconstructed_signal\r\n\r\n\r\ndef cubic_spline_interp(sample_points, sample_values, interpolated_points):\r\n        \r\n    cubic_spline = CubicSpline(sample_points, sample_values)\r\n    \r\n    # Evaluate the spline over the full time range\r\n    reconstructed_signal = cubic_spline(interpolated_points)\r\n    \r\n    return reconstructed_signal\r\n\r\ndef sample_and_reconstruct(time, signal, sampling_rate, interp_method):\r\n    sample_indices = np.linspace(0, len(time) - 1, sampling_rate).astype(int)\r\n    sampled_time = time[sample_indices]\r\n    sampled_signal = signal[sample_indices]\r\n    reconstructed_signal = interp_method(sampled_time, sampled_signal, time)\r\n    return sampled_time, sampled_signal, reconstructed_signal\r\n\r\ndef calculate_error(original_signal, reconstructed_signal):\r\n    \"\"\"Calculate the absolute error between the original and reconstructed signals.\"\"\"\r\n    return np.abs(original_signal - reconstructed_signal)\r\n\r\ndef calculate_frequency_domain(signal, time):\r\n    \"\"\"Calculate the frequency domain representation of the given signal.\"\"\"\r\n    freqs = fftfreq(len(time), time[1] - time[0])\r\n    fft_signal = np.abs(fft(signal))\r\n\r\n    # Scale the FFT result\r\n    fft_signal[1:] *= 2\r\n    fft_signal /= len(time)\r\n\r\n    return freqs, fft_signal\r\n\r\ndef calculate_max_frequency(signal, time):\r\n    \"\"\"Calculate the maximum frequency of the signal.\"\"\"\r\n    # Find the Nyquist frequency\r\n    sampling_rate = 1 / (time[1] - time[0])\r\n    max_frequency = sampling_rate / 2\r\n    return max_frequency\r\n\r\nclass SignalSamplingApp(QtWidgets.QWidget):\r\n    def __init__(self, csv_file_path):\r\n        super().__init__()\r\n\r\n        self.data_loader = DataLoader(csv_file_path)  # Load data from CSV\r\n        self.signal = self.data_loader.get_data().flatten()  # Flatten to ensure 1D array\r\n        self.max_time_axis = len(self.signal)\r\n        self.time = np.linspace(0, self.max_time_axis / 1000, self.max_time_axis)  # Assuming a sample rate of 1000Hz\r\n\r\n        self.f_max = calculate_max_frequency(self.signal, self.time)\r\n        self.sampling_rate = 2\r\n\r\n        self.initUI()\r\n        self.interp_methods = {\r\n            \"Whittaker-Shannon (sinc)\": sinc_interp,\r\n            \"Linear\": linear_interp,\r\n            \"Zero-Order Hold\": zoh_reconstruction,\r\n            \"Cubic-Spline\":cubic_spline_interp\r\n        }\r\n\r\n        self.interp_method = self.interp_methods[\"Whittaker-Shannon (sinc)\"]\r\n\r\n        self.update_sampling_slider()\r\n        self.sample_and_reconstruct()\r\n\r\n    def initUI(self):\r\n        self.setWindowTitle(\"Signal Sampling and Recovery\")\r\n        self.setGeometry(100, 100, 1200, 800)\r\n\r\n        layout = QtWidgets.QVBoxLayout()\r\n        self.setLayout(layout)\r\n\r\n        # Create plots\r\n        self.original_plot = pg.PlotWidget(title=\"Original Signal\")\r\n        self.reconstructed_plot = pg.PlotWidget(title=\"Reconstructed Signal\")\r\n        self.error_plot = pg.PlotWidget(title=\"Absolute Error (Original - Reconstructed)\")\r\n        self.frequency_plot = pg.PlotWidget(title=\"Frequency Domain\")\r\n\r\n        # Add plots vertically\r\n        layout.addWidget(self.original_plot)\r\n        layout.addWidget(self.reconstructed_plot)\r\n        layout.addWidget(self.error_plot)\r\n        layout.addWidget(self.frequency_plot)\r\n\r\n        # Slider for sampling\r\n        control_panel = QtWidgets.QHBoxLayout()\r\n        self.sampling_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\r\n        self.sampling_slider.setMinimum(2)\r\n        self.sampling_slider.setMaximum(int(4 * self.f_max))\r\n        self.sampling_slider.setTickPosition(QtWidgets.QSlider.TicksBelow)\r\n        self.sampling_slider.setTickInterval(1)\r\n        self.sampling_slider.setValue(self.sampling_rate)\r\n        self.sampling_slider.valueChanged.connect(self.update_sampling)\r\n\r\n        self.sampling_label = QtWidgets.QLabel(f\"Sampling Frequency: {self.sampling_rate}\")\r\n        control_panel.addWidget(self.sampling_slider)\r\n        control_panel.addWidget(self.sampling_label)\r\n        layout.addLayout(control_panel)\r\n\r\n        # Reconstruction method selection\r\n        reconstruction_layout = QtWidgets.QHBoxLayout()\r\n        self.reconstruction_method_label = QtWidgets.QLabel(\"Reconstruction Method: \")\r\n        reconstruction_layout.addWidget(self.reconstruction_method_label)\r\n\r\n        self.reconstruction_method_comboBox = QtWidgets.QComboBox(self)\r\n        self.reconstruction_method_comboBox.addItems(\r\n            [\"Whittaker-Shannon (sinc)\", \"Linear\"])\r\n        self.reconstruction_method_comboBox.currentTextChanged.connect(self.update_reconstruction_method)\r\n\r\n        reconstruction_layout.addWidget(self.reconstruction_method_comboBox)\r\n        control_panel.addLayout(reconstruction_layout)\r\n\r\n        layout.addLayout(control_panel)\r\n\r\n    def update_sampling_slider(self):\r\n        \"\"\"Reconfigure the sampling slider based on the current f_max.\"\"\"\r\n        self.sampling_slider.setMaximum(int((4 * self.f_max)))\r\n        self.sampling_slider.setTickInterval(int(self.f_max))\r\n        self.sampling_slider.setValue(min(self.sampling_rate, 4 * self.f_max))\r\n        self.sampling_label.setText(f\"Sampling Frequency: {self.sampling_slider.value()}\")\r\n\r\n    def update_sampling(self):\r\n        self.sampling_rate = self.sampling_slider.value()\r\n        normalized_frequency = self.sampling_rate / self.f_max  # Normalized frequency calculation\r\n        self.sampling_label.setText(\r\n            f\"Sampling Frequency: {self.sampling_rate} (Normalized: {normalized_frequency:.2f})\")\r\n        self.sample_and_reconstruct()\r\n\r\n    def update_reconstruction_method(self, method_name):\r\n        \"\"\"Update the interpolation method based on user selection.\"\"\"\r\n        self.interp_method = self.interp_methods[method_name]  # Set to the actual function\r\n        self.sample_and_reconstruct()  # Call to update the signal with the new method\r\n\r\n    def sample_and_reconstruct(self):\r\n        sampled_time, sampled_signal, reconstructed_signal = sample_and_reconstruct(\r\n            self.time, self.signal, self.sampling_rate, self.interp_method)\r\n\r\n        self.update_plots(sampled_time, sampled_signal, reconstructed_signal)\r\n\r\n    def update_plots(self, sampled_time=None, sampled_signal=None, reconstructed_signal=None):\r\n        self.original_plot.clear()\r\n        self.reconstructed_plot.clear()\r\n        self.error_plot.clear()\r\n        self.frequency_plot.clear()\r\n\r\n        # Plot original signal\r\n        self.original_plot.plot(self.time, self.signal, pen='#007AFF', name=\"Original Signal\")\r\n        if sampled_time is not None and sampled_signal is not None:\r\n            self.original_plot.plot(sampled_time, sampled_signal, pen=None, symbol='o', symbolBrush='r',\r\n                                    size=5)  # Adjust size\r\n\r\n        # Plot reconstructed signal\r\n        if reconstructed_signal is not None:\r\n            self.reconstructed_plot.plot(self.time, reconstructed_signal, pen='#007AFF')\r\n\r\n            # Calculate and plot absolute error\r\n            error = calculate_error(self.signal, reconstructed_signal)  # Calculate absolute error\r\n            self.error_plot.plot(self.time, error, pen='#FF0000')  # Plot absolute error in red\r\n\r\n            # Frequency domain plot for original and reconstructed signals\r\n            freqs_original, fft_original = calculate_frequency_domain(self.signal, self.time)\r\n            freqs_reconstructed, fft_reconstructed = calculate_frequency_domain(reconstructed_signal, self.time)\r\n\r\n            self.frequency_plot.plot(freqs_original[:len(freqs_original) // 2], fft_original[:len(freqs_original) // 2],\r\n                                     pen='#007AFF')\r\n            self.frequency_plot.plot(freqs_reconstructed[:len(freqs_reconstructed) // 2],\r\n                                     fft_reconstructed[:len(freqs_reconstructed) // 2], pen=pg.mkPen('r', width=5))\r\n\r\n        # Set view range for original and reconstructed plots\r\n        self.original_plot.setXRange(self.time[0], self.time[-1])\r\n        self.original_plot.setYRange(np.min(self.signal), np.max(self.signal))\r\n        self.reconstructed_plot.setXRange(self.time[0], self.time[-1])\r\n        self.reconstructed_plot.setYRange(np.min(self.signal), np.max(self.signal))\r\n\r\n        # Set view range for error plot\r\n        self.error_plot.setXRange(self.time[0], self.time[-1])\r\n        self.error_plot.setYRange(0, np.max(error))\r\n\r\n        # Set view range for frequency plot\r\n        self.frequency_plot.setXRange(0, (1 / (self.time[1] - self.time[0])) / 2)  # Nyquist frequency\r\n        self.frequency_plot.setYRange(0, np.max([fft_original, fft_reconstructed]).max())  # Set to max of both signals\r\n\r\n    def main(self):\r\n        self.show()\r\n\r\n\r\nif __name__ == '__main__':\r\n    csv_file_path = '../signals_data/EEG_Abnormal.csv'  # Specify the path to your CSV file\r\n    app = QtWidgets.QApplication(sys.argv)\r\n    window = SignalSamplingApp(csv_file_path)\r\n    window.main()\r\n    sys.exit(app.exec_())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Core/mainCore.py b/Core/mainCore.py
--- a/Core/mainCore.py	(revision 31031d20a9f15037c813b1a7e605c11f854f9f7a)
+++ b/Core/mainCore.py	(date 1730149832010)
@@ -102,11 +102,16 @@
     def __init__(self, csv_file_path):
         super().__init__()
 
+        # self.data_loader = DataLoader(csv_file_path)  # Load data from CSV
+        # self.signal = self.data_loader.get_data().flatten()  # Flatten to ensure 1D array
+        # self.max_time_axis = len(self.signal)
+        # self.time = np.linspace(0, self.max_time_axis / 1000, self.max_time_axis)  # Assuming a sample rate of 1000Hz
         self.data_loader = DataLoader(csv_file_path)  # Load data from CSV
-        self.signal = self.data_loader.get_data().flatten()  # Flatten to ensure 1D array
-        self.max_time_axis = len(self.signal)
-        self.time = np.linspace(0, self.max_time_axis / 1000, self.max_time_axis)  # Assuming a sample rate of 1000Hz
+        data = self.data_loader.get_data()  # Get the loaded data as a NumPy array
+        self.time = data[:, 0]  # Extract the first column as time
+        self.signal = data[:, 1]  # Extract the second column as amplitude
 
+        # self.max_time_axis = len(self.signal)
         self.f_max = calculate_max_frequency(self.signal, self.time)
         self.sampling_rate = 2
 
@@ -164,7 +169,7 @@
 
         self.reconstruction_method_comboBox = QtWidgets.QComboBox(self)
         self.reconstruction_method_comboBox.addItems(
-            ["Whittaker-Shannon (sinc)", "Linear"])
+            ["Whittaker-Shannon (sinc)", "Linear","Zero-Order Hold"," Cubic-Spline"])
         self.reconstruction_method_comboBox.currentTextChanged.connect(self.update_reconstruction_method)
 
         reconstruction_layout.addWidget(self.reconstruction_method_comboBox)
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"cf936afa-7aac-4859-a24f-60ffba97b4aa\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/GUI/main.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/GUI/main.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;Meram-Mahmoud&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/TalalEmara/Signal-Reconstructor.git&quot;,\r\n    &quot;accountId&quot;: &quot;8bed304c-abb0-4097-a812-4dce8c1a20cd&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 2\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2nvZIqT76889PWggeLxJcsqbufU\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Python.main.py.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.mainCore.executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;D:/Faculty/SBE 24-25/DSP/Signal-Reconstructor&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"main.py\" type=\"PythonConfigurationType\" factoryName=\"Python\">\r\n      <module name=\"Signal-Reconstructor\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/GUI/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-js-predefined-d6986cc7102b-5c90d61e3bab-JavaScript-PY-242.23339.19\" />\r\n        <option value=\"bundled-python-sdk-0029f7779945-399fe30bd8c1-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-242.23339.19\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"cf936afa-7aac-4859-a24f-60ffba97b4aa\" name=\"Changes\" comment=\"\" />\r\n      <created>1729855432731</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1729855432731</updated>\r\n      <workItem from=\"1729889981670\" duration=\"3614000\" />\r\n      <workItem from=\"1730056188815\" duration=\"9055000\" />\r\n      <workItem from=\"1730121898571\" duration=\"1610000\" />\r\n      <workItem from=\"1730124364628\" duration=\"1485000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 31031d20a9f15037c813b1a7e605c11f854f9f7a)
+++ b/.idea/workspace.xml	(date 1730150629776)
@@ -5,6 +5,10 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="cf936afa-7aac-4859-a24f-60ffba97b4aa" name="Changes" comment="">
+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Core/Data_load.py" beforeDir="false" afterPath="$PROJECT_DIR$/Core/Data_load.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Core/mainCore.py" beforeDir="false" afterPath="$PROJECT_DIR$/Core/mainCore.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/GUI/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/GUI/main.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -42,26 +46,28 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;Python.main.py.executor&quot;: &quot;Run&quot;,
-    &quot;Python.mainCore.executor&quot;: &quot;Run&quot;,
-    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
-    &quot;last_opened_file_path&quot;: &quot;D:/Faculty/SBE 24-25/DSP/Signal-Reconstructor&quot;,
-    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
-    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
-    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
-    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
-    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;,
-    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "Python.main.executor": "Run",
+    "Python.main.py.executor": "Run",
+    "Python.mainCore.executor": "Run",
+    "RunOnceActivity.OpenProjectViewOnStart": "true",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "git-widget-placeholder": "main",
+    "last_opened_file_path": "D:/Faculty/SBE 24-25/DSP/Signal-Reconstructor",
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)",
+    "nodejs_package_manager_path": "npm",
+    "settings.editor.selected.configurable": "com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable",
+    "vue.rearranger.settings.migration": "true"
   }
-}</component>
+}]]></component>
   <component name="RunManager">
     <configuration name="main.py" type="PythonConfigurationType" factoryName="Python">
       <module name="Signal-Reconstructor" />
+      <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
       <envs>
@@ -109,4 +115,9 @@
   <component name="TypeScriptGeneratedFilesManager">
     <option name="version" value="3" />
   </component>
+  <component name="com.intellij.coverage.CoverageDataManagerImpl">
+    <SUITE FILE_PATH="coverage/Signal_Reconstructor$mainCore.coverage" NAME="mainCore Coverage Results" MODIFIED="1730150520041" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Core" />
+    <SUITE FILE_PATH="coverage/Signal_Reconstructor$main.coverage" NAME="main Coverage Results" MODIFIED="1730150525949" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/GUI" />
+    <SUITE FILE_PATH="coverage/Signal_Reconstructor$main_py.coverage" NAME="main.py Coverage Results" MODIFIED="1730124365886" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="" />
+  </component>
 </project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"Black\">\r\n    <option name=\"sdkName\" value=\"Python 3.10 (Signal-Viewer-Team18)\" />\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.11 (Signal-Reconstructor)\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 31031d20a9f15037c813b1a7e605c11f854f9f7a)
+++ b/.idea/misc.xml	(date 1730146304648)
@@ -3,5 +3,5 @@
   <component name="Black">
     <option name="sdkName" value="Python 3.10 (Signal-Viewer-Team18)" />
   </component>
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.11 (Signal-Reconstructor)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.11" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
